"""
JCL generation for FORTRAN compile, link, and go.
"""

import re
from typing import Optional, List
from dataclasses import dataclass
from enum import Enum


def sanitize_name(name: str) -> str:
    """Sanitize a name for MVS (alphanumeric only, max 8 chars, start with letter)."""
    # Remove underscores and other non-alphanumeric chars
    clean = re.sub(r'[^A-Za-z0-9]', '', name)
    # Ensure starts with letter
    if clean and not clean[0].isalpha():
        clean = 'J' + clean
    # Truncate to 8 chars and uppercase
    return clean[:8].upper() if clean else 'FORTJOB'


class Compiler(Enum):
    """Available FORTRAN compilers."""
    G = "IEYFORT"   # FORTRAN G (1966) - basic compiler
    H = "IEKAA00"   # FORTRAN H (1969) - optimizing compiler


@dataclass
class CompileOptions:
    """Options for FORTRAN compilation."""
    compiler: Compiler = Compiler.G
    source_list: bool = True    # Generate source listing
    object_deck: bool = False   # Punch object deck
    load_module: bool = True    # Generate object module for linker
    map: bool = False           # Generate map listing
    xref: bool = False          # Generate cross-reference
    optimize: int = 0           # Optimization level (H compiler only)


@dataclass
class LinkOptions:
    """Options for linkage editor."""
    entry_point: Optional[str] = None  # Entry point name
    map: bool = True                    # Generate link map
    xref: bool = False                  # Generate cross-reference
    let: bool = True                    # Link even with errors


@dataclass
class ExecuteOptions:
    """Options for program execution."""
    region: str = "256K"        # Region size
    time: int = 5               # Time limit in minutes
    input_data: Optional[str] = None  # Input data for program


def generate_compile_only_jcl(
    source_code: str,
    job_name: str = "FORTCOMP",
    options: Optional[CompileOptions] = None
) -> str:
    """Generate JCL for compile-only job."""
    options = options or CompileOptions()
    job_name = sanitize_name(job_name)

    # Build PARM string
    parm_parts = []
    if options.source_list:
        parm_parts.append("SOURCE")
    else:
        parm_parts.append("NOSOURCE")
    if options.object_deck:
        parm_parts.append("DECK")
    else:
        parm_parts.append("NODECK")
    if options.load_module:
        parm_parts.append("LOAD")
    else:
        parm_parts.append("NOLOAD")
    if options.map:
        parm_parts.append("MAP")
    else:
        parm_parts.append("NOMAP")

    parm = ",".join(parm_parts)

    jcl = f"""//{job_name} JOB (1),'FORTRAN COMPILE',CLASS=A,MSGCLASS=A,
//         MSGLEVEL=(1,1)
//*
//* FORTRAN COMPILE - GENERATED BY FORTRAN360
//*
//FORT     EXEC PGM={options.compiler.value},PARM='{parm}',REGION=100K
//SYSPRINT DD SYSOUT=A
//SYSPUNCH DD SYSOUT=B
//SYSLIN   DD SYSOUT=B
//SYSIN    DD *
{source_code}
/*
//
"""
    return jcl


def generate_compile_link_jcl(
    source_code: str,
    job_name: str = "FORTCLG",
    load_name: str = "MAIN",
    compile_options: Optional[CompileOptions] = None,
    link_options: Optional[LinkOptions] = None
) -> str:
    """Generate JCL for compile and link job."""
    compile_options = compile_options or CompileOptions()
    link_options = link_options or LinkOptions()
    job_name = sanitize_name(job_name)
    load_name = sanitize_name(load_name)

    # Compiler PARM
    parm_parts = ["SOURCE", "NODECK", "LOAD", "NOMAP"]
    parm = ",".join(parm_parts)

    # Linker PARM
    link_parm_parts = []
    if link_options.map:
        link_parm_parts.append("MAP")
    if link_options.let:
        link_parm_parts.append("LET")
    link_parm = ",".join(link_parm_parts) if link_parm_parts else "MAP,LET"

    jcl = f"""//{job_name} JOB (1),'FORTRAN CLG',CLASS=A,MSGCLASS=A,
//         MSGLEVEL=(1,1)
//*
//* FORTRAN COMPILE AND LINK - GENERATED BY FORTRAN360
//*
//* STEP 1: COMPILE
//FORT     EXEC PGM={compile_options.compiler.value},PARM='{parm}',REGION=100K
//SYSPRINT DD SYSOUT=A
//SYSPUNCH DD DUMMY
//SYSLIN   DD DSN=&&OBJMOD,DISP=(NEW,PASS),UNIT=SYSDA,
//            SPACE=(TRK,(10,10)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=400)
//SYSIN    DD *
{source_code}
/*
//*
//* STEP 2: LINK
//LKED     EXEC PGM=IEWL,PARM='{link_parm}',COND=(8,LT,FORT),REGION=128K
//SYSPRINT DD SYSOUT=A
//SYSLIB   DD DSN=SYS1.FORTLIB,DISP=SHR
//SYSLIN   DD DSN=&&OBJMOD,DISP=(OLD,DELETE)
//SYSLMOD  DD DSN=&&GOSET({load_name}),DISP=(NEW,PASS),UNIT=SYSDA,
//            SPACE=(TRK,(10,10,1)),DCB=(RECFM=U,BLKSIZE=6144)
//SYSUT1   DD UNIT=SYSDA,SPACE=(TRK,(10,10))
//
"""
    return jcl


def generate_compile_link_go_jcl(
    source_code: str,
    job_name: str = "FORTCLG",
    load_name: str = "MAIN",
    compile_options: Optional[CompileOptions] = None,
    link_options: Optional[LinkOptions] = None,
    execute_options: Optional[ExecuteOptions] = None
) -> str:
    """Generate JCL for compile, link, and go job."""
    compile_options = compile_options or CompileOptions()
    link_options = link_options or LinkOptions()
    execute_options = execute_options or ExecuteOptions()
    job_name = sanitize_name(job_name)
    load_name = sanitize_name(load_name)

    # Compiler PARM
    parm = "SOURCE,NODECK,LOAD,NOMAP"

    # Linker PARM
    link_parm = "MAP,LET"

    # Build input data section if provided
    input_section = ""
    if execute_options.input_data:
        input_section = f"""//SYSIN    DD *
{execute_options.input_data}
/*"""
    else:
        input_section = "//SYSIN    DD DUMMY"

    # FORTRAN H uses cataloged procedure FORTHCLG
    if compile_options.compiler == Compiler.H:
        # Use the cataloged procedure for FORTRAN H
        jcl = f"""//{job_name} JOB (1),'FORTRAN H CLG',CLASS=A,MSGCLASS=A,
//         MSGLEVEL=(1,1)
//*
//* FORTRAN H COMPILE, LINK, AND GO - USING FORTHCLG PROC
//*
//CLG      EXEC FORTHCLG,REGION.FORT=384K
//FORT.SYSIN DD *
{source_code}
/*
{input_section}
//
"""
    else:
        # FORTRAN G - inline JCL
        fort_region = "100K"
        fort_step = f"""//FORT     EXEC PGM={compile_options.compiler.value},PARM='{parm}',REGION={fort_region}
//SYSPRINT DD SYSOUT=A
//SYSPUNCH DD DUMMY
//SYSLIN   DD DSN=&&OBJMOD,DISP=(NEW,PASS),UNIT=SYSDA,
//            SPACE=(TRK,(10,10)),DCB=(RECFM=FB,LRECL=80,BLKSIZE=400)"""

        jcl = f"""//{job_name} JOB (1),'FORTRAN CLG',CLASS=A,MSGCLASS=A,
//         MSGLEVEL=(1,1)
//*
//* FORTRAN COMPILE, LINK, AND GO - GENERATED BY FORTRAN360
//*
//* STEP 1: COMPILE
{fort_step}
//SYSIN    DD *
{source_code}
/*
//*
//* STEP 2: LINK
//LKED     EXEC PGM=IEWL,PARM='{link_parm}',COND=(8,LT,FORT),REGION=128K
//SYSPRINT DD SYSOUT=A
//SYSLIB   DD DSN=SYS1.FORTLIB,DISP=SHR
//SYSLIN   DD DSN=&&OBJMOD,DISP=(OLD,DELETE)
//SYSLMOD  DD DSN=&&GOSET({load_name}),DISP=(NEW,PASS),UNIT=SYSDA,
//            SPACE=(TRK,(10,10,1)),DCB=(RECFM=U,BLKSIZE=6144)
//SYSUT1   DD UNIT=SYSDA,SPACE=(TRK,(10,10))
//*
//* STEP 3: GO (EXECUTE)
//GO       EXEC PGM=*.LKED.SYSLMOD,COND=((8,LT,FORT),(4,LT,LKED)),
//             REGION={execute_options.region},TIME={execute_options.time}
//SYSPRINT DD SYSOUT=A
//FT05F001 DD DUMMY
//FT06F001 DD SYSOUT=A
//FT07F001 DD SYSOUT=B
{input_section}
//
"""
    return jcl
